% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conditions.R
\name{condition}
\alias{condition}
\alias{pkg_error}
\alias{pkg_warning}
\alias{pkg_message}
\title{Raise a mutable and classed condition.}
\usage{
condition(msg, cond = .conditions, ...,
  scope = environmentName(topenv(parent.frame())), type = NULL,
  call = sys.call(1))

pkg_error(msg, ..., scope = environmentName(topenv(parent.frame())),
  call = sys.call(1))

pkg_warning(msg, ..., scope = environmentName(topenv(parent.frame())),
  call = sys.call(1))

pkg_message(msg, ..., scope = environmentName(topenv(parent.frame())),
  call = sys.call(1))
}
\arguments{
\item{msg}{The message to convey}

\item{cond}{The severity of the condition, or what to do;
give a 'message' (default), a 'warning', an 'error'
or do 'none' and ignore.}

\item{...}{Attributes to be added to condition object for `condition`,
arguments passed to condition for all others.}

\item{scope}{A character vector of the scope(s) of the signal.
Defaults to the package name but could be longer such as
package name, a class name, and a method call.
This should be used as a where the error occured.}

\item{type}{Used with `scope` and `cond` to set the class of the condition object to raise.
This should be a type of error; out of bounds, type mismatch, ectetera.}

\item{call}{The call to use to include in the condition.}
}
\description{
Raising Classed conditions helps with catching errors.
These allow for typing errors as they arrise and adding scopes
to better catch errors from specific locations.
}
\details{
The `condition()` function alone provides a flexible and dynamic way of
producing conditions in code. The functions `pkg_error`, `pkg_warning`,
and `pkg_message` do the same as condition except restricted to errors, warnings,
and messages respectively.
}
